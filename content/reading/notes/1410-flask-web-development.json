{"date": "2014-10-02", "source": "d4fb9fdf-a92f-4236-b624-1eebadba31d4.html", "notes": [{"content": "Tables have a special column called the primary key, which holds a unique identifier foreach row stored in the table. Tables can also have columns called foreign keys, whichreference the primary key of another row from the same or another table. These linksbetween rows are called relationships and are the foundation of the relational databasemodel.", "time": "2014-10-02 17:43:45"}, {"content": "Table 5-1. Flask-SQLAlchemy database URLsDatabase engine URLMySQL\nmysql://username:password@hostname/databasePostgres\npostgresql://username:password@hostname/databaseSQLite (Unix)\nsqlite:////absolute/path/to/databaseSQLite (Windows) sqlite:///c:/absolute/path/to/database", "time": "2014-10-02 17:50:06"}, {"content": "db = SQLAlchemy(app)The db object instantiated from class SQLAlchemy represents the database and providesaccess to all the functionality of Flask-SQLAlchemy.", "time": "2014-10-02 17:51:46"}, {"content": "Table 5-3. Most common SQLAlchemy column optionsOption name\nDescriptionprimary_key If set to True, the column is the table\u2019s primary key.unique\nIf set to \nTrue, do not allow duplicate values for this column.index\nIf set to \nTrue, create an index for this column, so that queries are more efficient.nullable\nIf set to \nTrue, allow empty values for this column. If set to False, the column will not allow nullvalues.default", "time": "2014-10-02 17:54:30"}, {"content": "The very first thing to do is to instruct Flask-SQLAlchemy to create a database basedon the model classes. The db.create_all() function does this:(venv) $ python hello.py shell&gt;&gt;&gt; from hello import db&gt;&gt;&gt; db.create_all()", "time": "2014-10-02 17:56:23"}, {"content": "Or, more concisely:&gt;&gt;&gt; db.session.add_all([admin_role, mod_role, user_role,...     user_john, user_susan, user_david])To write the objects to the database, the session needs to be committed by calling itscommit()\n method:&gt;&gt;&gt; db.session.commit()", "time": "2014-10-02 17:59:18"}, {"content": "Database sessions are extremely useful in keeping the database consistent. The commitoperation writes all the objects that were added to the session atomically. If an erroroccurs while the session is being written, the whole session is discarded. If you alwayscommit related changes together in a session, you are guaranteed to avoid databaseinconsistencies due to partial updates.", "time": "2014-10-02 18:00:03"}, {"content": "Flask-SQLAlchemy makes a query object available in each model class. The most basicquery for a model is the one that returns the entire contents of the corresponding table:&gt;&gt;&gt; Role.query.all()[&lt;Role u'Administrator'&gt;, &lt;Role u'User'&gt;]", "time": "2014-10-02 18:01:55"}, {"content": "Table 5-5. Common SQLAlchemy query filtersOption\nDescriptionfilter()\nReturns a new query that adds an additional filter to the original queryfilter_by() Returns a new query that adds an additional equality filter to the original querylimit()\nReturns a new query that limits the number of results of the original query to the given numberoffset()\nReturns a new query that applies an offset into the list of results of the original queryorder_by()\nReturns a new query that sorts the results of the original query according to the given criteriagroup_by()", "time": "2014-10-02 18:02:15"}, {"content": "Table 5-6. Most common SQLAlchemy query executorsOption\nDescriptionall()\nReturns all the results of a query as a listfirst()\nReturns the first result of a query, or \nNone if there are no resultsfirst_or_404() Returns the first result of a query, or aborts the request and sends a 404 error as response if thereare no resultsget()\nReturns the row that matches the given primary key, or \nNone if no matching row is foundget_or_404()\nReturns the row that matches the given primary key. If the key is not found it aborts the request andsends a 404 error as responsecount()\nReturns the result count of the querypaginate()\nReturns a", "time": "2014-10-02 18:03:47"}, {"content": "A better solution is to use a database migration framework. In the same way source codeversion control tools keep track of changes to source code files, a database migrationframework keeps track of changes to a database schema, and then incremental changescan be applied to the database.", "time": "2014-10-02 19:03:57"}, {"content": "Before database migrations can be maintained, it is necessary to create a migrationrepository with the init subcommand:(venv) $ python hello.py db init", "time": "2014-10-02 19:11:57"}, {"content": "This command creates a migrations folder, where all the migration scripts will be stored.\nThe files in a database migration repository must always be added toversion control along with the rest of the application", "time": "2014-10-02 19:05:59"}, {"content": "The migrate subcommand creates an automatic migration script:(venv) $ python hello.py db migrate -m \"initial migration\"", "time": "2014-10-02 19:12:09"}, {"content": "Once a migration script has been reviewed and accepted, it can be applied to the databaseusing the db upgrade command:(venv) $ python hello.py db upgrade", "time": "2014-10-02 19:12:21"}, {"content": "Table 6-1. Flask-Mail SMTP server configuration keysKey\nDefault DescriptionMAIL_HOSTNAME localhost Hostname or IP address of the email serverMAIL_PORT\n25\nPort of the email serverMAIL_USE_TLS False Enable Transport Layer Security (TLS) securityMAIL_USE_SSL False Enable Secure Sockets Layer (SSL) securityMAIL_USERNAME None\nMail account usernameMAIL_PASSWORD None", "time": "2014-10-02 19:17:07"}], "duokanbookid": "m52471cd22g52752216849eef2egde87", "title": "Flask Web Development"}
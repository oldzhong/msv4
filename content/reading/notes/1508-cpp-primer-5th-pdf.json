{"date": "2015-08-22", "source": "3b20e253-8bbe-4e12-86b6-8ca962e4fe9f.html", "notes": [{"content": "This chapter introduces most of the basic elements of C++: types, variables,expressions, statements, and functions. Along the way, we\u2019ll briefly explain how tocompile and execute a program", "time": "2015-08-22 08:14:36"}, {"content": "A stream is a sequence of characters read from orwritten to an IO device. The term \nstream is intended to suggest that the charactersare generated, or consumed, sequentially over time", "time": "2015-08-22 08:22:42"}, {"content": "The second operator prints endl, which is a special value called a manipulator.Writing endl has the effect of ending the current line and flushing the \nbufferassociated with that device. Flushing the buffer ensures that all the output theprogram has generated so far is actually written to the output stream, rather thansitting in memory waiting to be written", "time": "2015-08-22 08:37:48"}, {"content": "When we use an istream as a condition, the effect is to test the state of thestream. If the stream is valid\u2014that is, if the stream hasn\u2019t encountered an error\u2014thenthe test succeeds. An istream becomes invalid when we hit \nend-of-file or encounteran invalid input, such as reading a value that is not an integer. An istream that is inan invalid state will cause the condition to yield false", "time": "2015-08-22 08:48:28"}, {"content": "A class defines a type alongwith a collection of operations that are related to that type", "time": "2015-08-22 08:57:40"}, {"content": "The remaining character types\u2014wchar_t, char16_t, and char32_t\u2014are usedfor extended character sets. The wchar_t type is guaranteed to be large enough tohold any character in the machine\u2019s largest extended character set. The typeschar16_t and char32_t are intended for Unicode characters. (Unicode is astandard for representing characters used in essentially any nat", "time": "2015-08-22 09:14:08"}, {"content": "However, thereturn type may not be an array type (\u00a7 3.5, p. 113) or a function type. However, afunction may return a pointer to an array or a function.", "time": "2015-09-04 13:34:06"}, {"content": "In C++, names have scope (\u00a7 2.2.4, p. 48), and objects have lifetimes. It isimportant to understand both of these concepts. \u2022 The scope of a name is \nthe part of the program\u2019s text in which that name isvisible. \u2022 The lifetime of an object is \nthe time during the program\u2019s execution that theobject exists.", "time": "2015-09-04 13:34:47"}, {"content": "Automatic objects corresponding to local variablesare initialized if their definition contains an initializer. Otherwise, they are defaultinitialized (\u00a7 2.2.1, p. 43), which means that uninitialized local variables of built-in typehave undefined values.", "comment": "\u6240\u4ee5\u5c40\u90e8\u53d8\u91cf\u5fc5\u987b\u521d\u59cb\u5316\uff1f", "time": "2015-09-04 13:41:13"}, {"content": "t can be useful to have a local variable whose lifetime continues across calls to thefunction. We obtain such objects by defining a local variable as static. Each localstatic object is initialized before the \nfirst time execution passes through the object\u2019sdefinition. Local statics are not destroyed when a function ends; they are destroyedwhen the program terminates.", "comment": "\u672c\u5730\u9759\u6001\u5bf9\u8c61\uff08\u53d8\u91cf\uff09", "time": "2015-09-04 13:38:49"}, {"content": "If a local static has no explicit initializer, it is value initialized (\u00a7 3.3.1, p. 98),meaning that local statics of built-in type are initialized to zero.", "time": "2015-09-04 13:40:10"}, {"content": "The compiler lets us \nlink object files together to form an executable. On the systemwe use, we would separately compile our program as follows: Click here to view code image $ CC -c factMain.cc     # generates factMain.o$ CC -c fact.cc         # generates fact.o$ CC factMain.o fact.o  # generates factMain.exe or a.out$ CC factMain.o fact.o -o main # generates main or main.exe", "comment": "\u770b\u6765\uff0c\u6e90\u6587\u4ef6\u662f\u53ef\u4ee5\u5355\u72ec\u7f16\u8bd1\u7684", "time": "2015-09-04 17:30:26"}, {"content": "If the parameter is a reference (\u00a7 2.3.1, p.50), then the parameter is bound to its argument. Otherwise, the argument\u2019s value iscopied", "time": "2015-09-04 17:34:21"}, {"content": "It can be inefficient to copy objects of large class types or large containers. Moreover,some class types (including the IO types) cannot be copied. Functions must usereference parameters to operate on objects of a type that cannot be copied", "time": "2015-09-04 17:37:31"}, {"content": "for (decltype(ret) i = 0; i != s.size(); ++i) {        if (s[i] == c) {             if (ret == s.size())                 ret = i;   // remember the first occurrence of c            ++occurs;      // increment the occurrence count         }    }", "comment": "\u8fd9\u4e2a\u5faa\u73af\u6709\u610f\u601d\uff0cdecltype\u76f8\u5f53\u4e8etypeof", "time": "2015-09-04 17:41:44"}, {"content": "Arrays have two special properties that affect how we define and use functions thatoperate on arrays: We cannot copy an array (\u00a7 3.5.1, p. 114), and when we use anarray it is (usually) converted to a pointer", "time": "2015-09-04 17:45:34"}, {"content": "Because arrays are passed as pointers, functions ordinarily don\u2019t know the size ofthe array they are given. They must rely on additional information provided by thecaller. There are three common techniques used to manage pointer parameters.", "time": "2015-09-04 17:47:21"}, {"content": "int j[2] = {0, 1};// j is converted to a pointer to the first element in j// the second argument is a pointer to one past the end of jprint(begin(j), end(j)); // begin and end functions, see \u00a7 3.5.3 (p. 118) This function is safe, as long as the caller correctly calculates the pointers. Here we letthe library begin and end functions (\u00a7 3.5.3, p. 118) provide those pointers.", "comment": "begin\u548cend\u4e5f\u53ef\u4ee5\u5bf9\u6570\u7ec4\u4f7f\u7528", "time": "2015-09-04 17:49:10"}, {"content": "The new standard provides two primary ways to write a function that takes avarying number of arguments: If all the arguments have the same type, we can passa library type named initializer_list. If the argument types vary, we can writea special kind of function, known as a variadic template, which we\u2019ll cover in \u00a7 16.4(p. 699).\n C", "time": "2015-09-04 17:54:24"}, {"content": "We can write our function to produce error messages from a varying number ofarguments as follows: Click here to view code image void error_msg(initializer_list<string> il){    for (auto beg = il.begin(); beg != il.end(); ++beg)        cout << *beg << \" \" ;    cout << endl;}", "time": "2015-09-04 17:56:26"}, {"content": "Ellipsis parameters are in C++ to allow programs to interface to C code that uses a Clibrary facility named varargs. Generally an ellipsis parameter should not be used forother purposes. Your C compiler documentation will describe how to use varargs.", "time": "2015-09-04 17:58:54"}, {"content": "Never Return a Reference or Pointer to a Local Object\n When a function completes, its storage is freed (\u00a7 6.1.1, p. 204). After a functionterminates, references to local objects refer to memory that is no longer valid:", "comment": "\u4e0d\u80fd\u8fd4\u56de\u672c\u5730\u5bf9\u8c61\u7684\u5f15\u7528\u6216\u6307\u9488", "time": "2015-09-04 18:03:27"}, {"content": "It may be surprising to see a function call on the left-hand side of an assignment.However, nothing special is involved. The return value is a reference, so the call is anlvalue. Like any other lvalue, it may appear as the left-hand operand of theassignment operator.", "comment": "\u51fd\u6570\u8c03\u7528\u4e5f\u53ef\u4f5c\u4e3a\u5de6\u503c", "time": "2015-09-04 18:07:55"}, {"content": "As a concrete example, the following declares func without using a type alias: int (*func(int i))[10]; To understand this declaration, it can be helpful to think about it as follows: \u2022 func(int) says that we can call func with an int argument. \u2022 (*func(int)) says we can dereference the result of that call. \u2022 (*func(int))[10] says that dereferencing the result of a call to func yieldsan array of size ten. \u2022 int (*func(int))[10] says the element type in that array is int.", "comment": "\u5982\u6b64\u590d\u6742\u5730\u5b9a\u4e49\u4e00\u4e2a\u51fd\u6570\uff0cC++\u771f\u4e0d\u6127\u662f\u4e00\u95e8\u9ed1\u6697\u7684\u8bed\u8a00\u554a\uff01", "time": "2015-09-04 18:15:35"}, {"content": "Under the new standard, another way to simplify the declaration of func is by usinga trailing return type. Trailing returns can be defined for any function, but are mostuseful for functions with complicated return types, such as pointers (or references) toarrays", "time": "2015-09-04 18:16:53"}, {"content": "// fcn takes an int argument and returns a pointer to an array of ten intsauto func(int i) -> int(*)[10]; Because the return type comes after the parameter list, it is easier to see that funcreturns a pointer and that that pointer points to an array of ten ints.", "time": "2015-09-04 18:17:14"}, {"content": "It is an error for two functions to differ only in terms of their return types. If theparameter lists of two functions match but the return types differ, then the seconddeclaration is an error:\n Click here to view code image Record lookup(const Account&);bool lookup(const Account&);   // error: only the return type is different", "time": "2015-09-04 06:22:16"}, {"content": "string &shorterString(string &s1, string &s2){    auto &r = shorterString(const_cast<const string&>(s1),                             const_cast<const string&>(s2));    return const_cast<string&>(r);} This version calls the const version of shorterString by casting its arguments toreferences to const. That function returns a reference to a const string, whichwe know is bound to one of our original, nonconst arguments. Therefore, we know itis safe to cast that string back to a plain string& in the return", "time": "2015-09-04 06:25:00"}, {"content": "When we call print, the compiler first looks for a declaration of that name. It findsthe local declaration for print that takes an int. Once a name is found, the compilerignores uses of that name in any outer scope. Instead, the compiler assumes that thedeclaration it found is the one for the name we are using. What remains is to see ifthe use of the name is valid.", "comment": "\u8de8\u4f5c\u7528\u57df\u4e0d\u91cd\u8f7d", "time": "2015-09-04 06:27:47"}, {"content": "window = screen(, , '?'); // error: can omit only trailing argumentswindow = screen('?');     // calls screen('?',80,' ') Note that the second call, which passes a single character value, is legal. Althoughlegal, it is unlikely to be what was intended. The call is legal because '?' is a char,and a char can be converted (\u00a7 4.11.1, p. 160) to the type of the left-mostparameter. That parameter is string::size_type, which is an unsigned integraltype", "comment": "\u4e0d\u50cfgo\uff0c\u65e0\u6cd5\u4ee5\u9017\u53f7\u66ff\u4ee3\u7a7a\u53c2\u6570\uff0c\u53ea\u80fd\u7701\u7565\u53f3\u9762\u7684\u53c2\u6570", "time": "2015-09-04 06:34:32"}, {"content": "There is, however, one potential drawback to making shorterString a function:Calling a function is apt to be slower than evaluating the equivalent expression. Onmost machines, a function call does a lot of work: Registers are saved before the calland restored after the return; arguments may be copied; and the program branches toa new location.\n inline Functions Avoid Function Call Overhead", "time": "2015-09-04 06:40:23"}, {"content": "In general, the inline mechanism is meant to optimize small, straight-line functionsthat are called frequently. Many compilers will not inline a recursive function. A 75-linefunction will almost surely not be expanded inline.", "time": "2015-09-04 06:41:33"}, {"content": "A constexpr function is a function that can be used in a constant expression (\u00a7 2.4.4,p. 65). A constexpr function is defined like any other function but must meet certainrestrictions: The return type and the type of each parameter in a must be a literaltype (\u00a7 2.4.4, p. 66), and the function body must contain exactly one returnstatement:", "time": "2015-09-04 06:43:54"}, {"content": "When it can do so, the compiler will replace a call to a constexpr function with itsresulting value. In order to be able to expand the function immediately, constexprfunctions are implicitly inline.", "time": "2015-09-04 06:44:16"}, {"content": "constexpr function body may contain other statements so long as thosestatements generate no actions at run time. For example, a constexpr function maycontain null statements, type aliases (\u00a7 2.5.1, p. 67), and using declarations", "time": "2015-09-04 06:44:54"}, {"content": "int arr[scale(2)]; // ok: scale(2) is a constant expressionint i = 2;         // i is not a constant expressionint a2[scale(i)];  // error: scale(i) is not a constant expression When we pass a constant expression\u2014such as the literal 2\u2014then the return is aconstant expression. In this case, the compiler will replace the call to scale with theresulting value.", "time": "2015-09-04 06:46:10"}, {"content": "Unlike other functions, inline and constexpr functions may be defined multipletimes in the program. After all, the compiler needs the definition, not just thedeclaration, in order to expand the code. However, all of the definitions of a giveninline or constexpr must match exactly. As a result, inline and constexprfunctions normally are defined in headers.\n Exercis", "time": "2015-09-04 06:47:17"}, {"content": "assert is a preprocessor macro. A preprocessor macro is a preprocessor variablethat acts somewhat like an inline function. The assert macro takes a singleexpression, which it uses as a condition: assert(expr);", "time": "2015-09-04 06:48:52"}, {"content": "The behavior of assert depends on the status of a preprocessor variable namedNDEBUG. If NDEBUG is defined, assert does nothing. By default, NDEBUG is \nnotdefined, so, by default, assert performs a run-time check. We can \u201cturn off\u201d debugging by providing a #define to define NDEBUG.Alternatively, most compilers provide a command-line option that lets us definepreprocessor variables", "time": "2015-09-04 06:51:20"}, {"content": "In addition to _ _func_ _, which the C++ compiler defines, the preprocessordefines four other names that can be useful in debugging: _ _FILE_ _ string literal containing the name of the file _ _LINE_ _ integer literal containing the current line number", "time": "2015-09-04 06:52:51"}, {"content": "_ _TIME_ _ string literal containing the time the file was compiled _ _DATE_ _ string literal containing the date the file was compiled", "time": "2015-09-04 06:53:05"}, {"content": "The second step selects from the set of candidate functions those functions that canbe called with the arguments in the given call. The selected functions are the viablefunctions", "time": "2015-09-04 13:08:27"}, {"content": "The compiler will reject this call because it is ambiguous: Each viable function is abetter match than the other on one of the arguments to the call. It might be temptingto force a match by explicitly casting (\u00a7 4.11.3, p. 162) one of our arguments.However, in well-designed systems, argument casts should not be necessary", "time": "2015-09-04 13:11:21"}, {"content": "Afunction\u2019s type is determined by its return type and the types of its parameters. Thefunction\u2019s name is not part of its type. For example: Click here to view code image // compares lengths of two stringsbool lengthCompare(const string &, const string &); has type bool(const string&, const string&). To declare a pointer that canpoint at this function, we declare a pointer in place of the function name: Click here to view code image // pf points to a function returning bool that takes two const string referencesbool (*pf)(const string &, const string &);  // uninitialized", "time": "2015-09-04 13:13:58"}, {"content": "When we use the name of a function as a value, the function is automaticallyconverted to a pointer. For example, we can assign the address of lengthCompareto pf as follows: Click here to view code image pf = lengthCompare;  // pf now points to the function named lengthComparepf = &lengthCompare; // equivalent assignment: address-of operator is optional", "comment": "\u52a0\u4e0d\u52a0\u53d6\u5730\u5740\u7b26\u90fd\u4e00\u6837\uff1f", "time": "2015-09-04 13:15:45"}, {"content": "There is no conversion between pointers to one function type and pointers toanother function type. However, as usual, we can assign nullptr (\u00a7 2.3.2, p. 53) ora zero-valued integer constant expression to a function pointer to indicate that thepointer does not point to any function:", "time": "2015-09-04 13:16:30"}, {"content": "Returning a Pointer to Function", "comment": "\u51fd\u6570\u6307\u9488\u4e0b\u9762\u5c31\u6ca1\u591a\u770b", "time": "2015-09-04 13:19:04"}, {"content": "In C++, functions may be overloaded: The same name may be used to definedifferent functions as long as the number or types of the parameters in the functionsdiffer. The compiler automatically figures out which function to call based on thearguments in a call. The process of selecting the right function from a set ofoverloaded functions is referred to as function matching.", "time": "2015-09-04 13:29:43"}, {"content": "In addition to supporting automatic and static objects, C++ lets us allocateobjects dynamically. Dynamically allocated objects have a lifetime that is independentof where they are created; they exist until they are explicitly freed.", "comment": "\u9664\u81ea\u52a8\u5bf9\u8c61\u548c\u9759\u6001\u5bf9\u8c61\u5916\uff0c\u8fd8\u6709\u4e00\u79cd\u52a8\u6001\u5206\u914d\u7684\u5bf9\u8c61\uff0c\u5c31\u662f\u90a3\u79cdnew\u51fa\u6765\u7684", "time": "2015-09-04 18:43:57"}, {"content": "Our programs have used only static or stack memory. Static memory is used for localstatic objects (\u00a7 6.1.1, p. 205), for class static data members (\u00a7 7.6, p. 300),and for variables defined outside any function. Stack memory is used for nonstaticobjects defined inside functions. Objects allocated in static or stack memory areautomatically created and destroyed by the compiler. Stack objects exist only while theblock in which they are defined is executing; static objects are allocated before theyare used, and they are destroyed when the program ends.", "comment": "\u6808\u4e0a\u9762\u7684\u5bf9\u8c61\u5728block\u4e2d\u7684\u67d0\u4e00\u884c\u521b\u5efa\uff0c\u5e76\u5728block\u7ed3\u675f\u540e\u9500\u6bc1", "time": "2015-09-04 18:47:21"}, {"content": "hat it can use. This memory is referred to as the free store or heap. Programs usethe heap for objects that they dynamically allocate\u2014that is, for objects that theprogram allocates at run time. The program controls the lifetime of dynamic objects;our code must explicitly destroy such objects when they are no longer needed.", "comment": "\u8fd9\u4e9b\u52a8\u6001\u5206\u914d\u7684\u5bf9\u8c61\uff0c\u4f4d\u4e8e\u81ea\u7531\u5b58\u50a8\u533a\uff08\u6216\u79f0\u5806\u533a\uff09\uff0c\u5176\u751f\u547d\u5468\u671f\u9700\u8981\u7a0b\u5e8f\u81ea\u5df1\u6765\u7ba1\u7406", "time": "2015-09-04 18:49:40"}, {"content": "Dynamic memory is problematic because it is surprisingly hard to ensure that wefree memory at the right time. Either we forget to free the memory\u2014in which case wehave a memory leak\u2014or we free the memory when there are still pointers referring tothat memory\u2014in which case we have a pointer that refers to memory that is nolonger valid.", "comment": "\u52a8\u6001\u5185\u5b58\u7684\u4e24\u5927\u75db\u70b9\uff1a\u5bb9\u6613\u6cc4\u9732\uff0c\u5bb9\u6613\u4ea7\u751f\u91ce\u6307\u9488", "time": "2015-09-04 18:52:30"}, {"content": "smart pointer types that manage dynamic objects. A smart pointer acts like aregular pointer with the important exception that it automatically deletes the object towhich it points. The new library defines two kinds of smart pointers that differ in howthey manage their underlying pointers: shared_ptr, which allows multiple pointers torefer to the same object, and unique_ptr, which \u201cowns\u201d the object to which it points.The library also defines a companion class named weak_ptr that is a weak referenceto an object managed by a shared_ptr. All three are defined in the memory header.\n 1", "comment": "\u4e09\u5927\u667a\u80fd\u6307\u9488\u7684\u5f15\u5165\uff0c\u5b83\u4eec\u90fd\u4f4d\u4e8ememory\u5934\u6587\u4ef6\u91cc", "time": "2015-09-04 18:54:49"}, {"content": "The safest way to allocate and use dynamic memory is to call a library function namedmake_shared. This function allocates and initializes an object in dynamic memoryand returns a shared_ptr that points to that object", "comment": "make_shared\u6bd4reset\u5b89\u5168\uff1f", "time": "2015-09-04 21:35:59"}, {"content": "We can think of a shared_ptr as if it has an associated counter, usually referred toas a reference count. Whenever we copy a shared_ptr, the count is incremented", "time": "2015-09-04 21:39:22"}, {"content": "The counter is decremented when we assign a new value tothe shared_ptr and when the shared_ptr itself is destroyed, such as when a localshared_ptr goes out of scope", "time": "2015-09-04 21:40:01"}, {"content": "The destructor for shared_ptr decrements the reference count of the object towhich that shared_ptr points. If the count goes to zero, the shared_ptrdestructor destroys the object to which the shared_ptr points and frees the memoryused by that object", "comment": "shared_ptr\u7684\u539f\u7406", "time": "2015-09-04 21:42:10"}, {"content": "One way that shared_ptrsmight stay around after you need them is if you put shared_ptrs in a container andsubsequently reorder the container so that you don\u2019t need all the elements. Youshould be sure to erase shared_ptr elements once you no longer need thoseelements", "time": "2015-09-04 21:48:09"}], "duokanbookid": "wb0f909g033dc8c36dd2e41bgg3f4dde", "title": "C++ Primer 5th"}
{"date": "2013-09-01", "source": "64b8921f-cc81-4d57-8891-0a0d642e1132.html", "notes": [{"content": "DFA-basedand  NFA-based  regular  expression  matching", "time": "2013-09-01 13:39:03"}, {"content": "it used abacktracking algorithm, meaning it is easy to make searches take exponential time or arbitrary stackdepth", "time": "2013-09-01 13:39:40"}, {"content": "The result,  RE2,provides  most  of  the  functionality  of  PCRE  using  a  C++  interface  very  close  to  PCRE's,  but  itguarantees linear time execution and a fixed stack footprint", "time": "2013-09-01 13:41:37"}, {"content": "RE2's  parsercreates a Regexp data structure, defined in regexp.h", "time": "2013-09-01 13:45:26"}, {"content": "RE2's parser is in parse.cc", "time": "2013-09-01 13:46:02"}, {"content": "Instead  the  parsermaintains an explicit parse stack, as a generated LR(1) parser would", "time": "2013-09-01 13:46:51"}, {"content": "It applies these simplifications during parsing, rather than ina second pass, to avoid a larger-than-necessary intermediate memory footprint", "time": "2013-09-01 13:50:14"}, {"content": "If the  RPN form  recorded the  maximum  stack depth  used in  the expression,  atraversal would allocate  a stack of exactly that  size and then zip through the  representation in asingle linear scan", "time": "2013-09-01 13:57:10"}, {"content": "Over time, most of the code in RE2's simplification pass moved into theparser, because simplifying eagerly keeps the intermediate memory footprint down", "time": "2013-09-01 14:03:27"}, {"content": "It compiles UTF-8 character classes down to an automaton that reads the input one byte at a time", "time": "2013-09-01 14:10:38"}, {"content": "common suffixes like the [80-BF] canbe factored out", "time": "2013-09-01 14:10:45"}, {"content": "The real irregularities come from character classes that have evolved overthe course of Unicode's history", "time": "2013-09-01 14:10:14"}, {"content": "Compiling  out  the  UTF-8  makes  the  compiler  a  little  more  complicated  but  makes  the  matchingengines much faster: they can process one byte at a time in tight loops", "time": "2013-09-01 14:12:01"}, {"content": "RE2::PartialMatch, which finds the first match in the input text", "time": "2013-09-01 14:13:42"}, {"content": "RE2::FullMatch, whichrequires  the  match  to  cover  the  entire  input", "time": "2013-09-01 14:13:46"}, {"content": "4.  Does the regular expression match a substring of the string? If so, where? Where are thesubmatches?\nRE2::PartialMatch(s, \"(r+)(e+)\", &m1, &m2)", "time": "2013-09-01 14:15:37"}, {"content": "the implementation distinguishes them because it can implement the earlierquestions much more efficiently than the later ones", "time": "2013-09-01 14:26:32"}, {"content": "The RE2 DFA treats its states as a cache; if the cache fills, the DFA frees them all and starts over", "time": "2013-09-01 14:20:31"}, {"content": "But we definitely want list insertionwith duplicate elimination in constant time. Luckily, there is a data structure designed exactly forthis  situation:  sparse  sets", "time": "2013-09-01 15:24:13"}, {"content": "We could reduce this question to the last one by rewriting re  into.*re.*, but we can do better by rewriting it to .*re and handling the trailing part separately", "time": "2013-09-01 15:27:19"}, {"content": "The DFA or the compiled program form can be analyzed to determinewhether  every  possible  match  starts  with  the  same  first  byte,  like  when  searching  for(research|random)", "time": "2013-09-01 15:29:56"}, {"content": "Remember that the caller only cares whether there is a match, not what it is, so it's okayfor the DFA not to look for the longest one", "time": "2013-09-01 15:32:07"}, {"content": "TheDFA code is written as a single generalized loop that looks at flags controlling its behavior, likewhether there is a literal first byte to look for or whether to stop as early as possible", "time": "2013-09-01 15:35:53"}, {"content": "If instead  we  treat  the DFA  state  as a  partially  ordered  set of  NFAstates, we can track which possibilities take priority over others, so that the DFA can identify theexact place where the match stops", "time": "2013-09-01 15:41:24"}, {"content": "report where a match ends, but if we run the DFA backward over the text, what the DFA sees as the end", "time": "2013-09-01 15:59:50"}, {"content": "The DFA is fast, but it can only answer the first twoparts", "time": "2013-09-01 15:48:04"}, {"content": "A direct NFA simulation is necessary to answer the third part", "time": "2013-09-01 15:48:22"}, {"content": "Once the DFA finds the match location, it is time to invoke the NFA to find submatch boundaries.", "time": "2013-09-01 15:49:49"}, {"content": "If all else fails, use the standard NFA", "time": "2013-09-01 15:55:01"}, {"content": "RE2  disallows  PCRE  features  that  cannot  be  implemented  efficiently  using  automata", "time": "2013-09-01 15:56:17"}, {"content": "InternationalizationRE2 treats regular expressions as describing Unicode sequences and can search text encoded in UTF-8 or Latin-1", "time": "2013-09-01 16:14:20"}, {"content": "RE2 has a small number of hand-written tests to check basic functionality, but it quickly became clearthat hand-written tests  alone would require too much  effort to create and maintain if  they were tocover  RE2  well", "time": "2013-09-01 16:18:52"}, {"content": "Then, for every regular expression and everyinput string,  the RE2 tests  check that the  output of the  four different regular  expression enginesagree with each other", "time": "2013-09-01 16:21:32"}, {"content": "Compilation. RE2 compiles regexps at about 3-4x slower than PCRE", "time": "2013-09-01 16:24:32"}, {"content": "RE2 does more analysis of the regexp during compilationand stores a richer form than PCRE. RE2 saves state (the partially-built DFA) across calls too: afterrunning a few matches a simple RE2 might be using 10kB, but more matches do not typically increase thefootprint.", "time": "2013-09-01 16:26:27"}, {"content": "RE2 uses the OnePass matching engine to run the search, avoiding the overhead of the full NFA", "time": "2013-09-01 16:28:21"}, {"content": "If the regexp is ambiguous,RE2  cannot  use  the  OnePass  engine,  but  if  the  regexp  and  string  are  both  small,  RE2  can  use  theBitState engine", "time": "2013-09-01 16:29:11"}, {"content": "Here, RE2 is  noticeably slower than PCRE, because  the regexp is not unambiguous: it  is never clearwhether an additional digit should be added to the [0-9]+ or used to match the \u2018.\u2019", "time": "2013-09-01 16:31:30"}, {"content": "RE2 excels at searches over large amounts of text. It can locate matches much faster than PCRE,especially if the search requires PCRE to backtrack", "time": "2013-09-01 16:37:52"}, {"content": "RE2 demonstrates that it is possible to use automata theory to implement almost all the featuresof a modern backtracking regular expression library like PCRE", "time": "2013-09-01 16:41:18"}], "duokanbookid": "td3f41cf6917df42d239bgbfb26f1f87", "title": "Regular Expression Matching in the Wild"}
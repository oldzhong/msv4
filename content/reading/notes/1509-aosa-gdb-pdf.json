{"date": "2015-09-08", "source": "56e3f106-62d4-44c6-aa12-b2bd6bfe932b.html", "notes": [{"content": "This chapter will delve into the overall internal structure of GDB, showing how it has gradually developed asnew user needs and new features have come in over time", "time": "2015-09-08 22:24:27"}, {"content": "The important point for design is that a tool like GDB is basically an interactive toolbox for poking around in aprogram, and as such it needs to be responsive to an unpredictable series of requests", "time": "2015-09-08 22:28:37"}, {"content": "GDB also needs to be able to debug programs compiled by different compilers (not just the GNU Ccompiler), to debug programs compiled years earlier by long-obsolete versions of compilers, and to debug", "time": "2015-09-08 22:29:20"}, {"content": "programs whose symbolic info is missing, out of date, or simply incorrect; so, another design considerationis that GDB should continue to work and be useful even if data about the program is missing, or corrupted,or simply incomprehensible", "time": "2015-09-08 22:29:36"}, {"content": "Figure 4.1: Overall structure of GDB", "time": "2015-09-08 22:31:17"}, {"content": "The \"symbol side\" is concerned with symbolic information about the program. Symbolic informationincludes function and variable names and types, line numbers, machine register usage, and so on. Thesymbol side extracts symbolic information from the program's executable file, parses expressions, findsthe memory address of a given line number, lists source code, and in general works with the program asthe programmer wrote it", "comment": "\u8fd9\u4e9b\u7b26\u53f7\u4fe1\u606f\u662f\u4ece\u53ef\u6267\u884c\u6587\u4ef6\u91cc\u9762\u62bd\u53d6\u51fa\u6765\u7684", "time": "2015-09-08 22:32:22"}, {"content": "The \"target side\" is concerned with the manipulation of the target system. It has facilities to start andstop the program, to read memory and registers, to modify them, to catch signals, and so on. Thespecifics of how this is done can vary drastically between systems; most Unix-type systems provide aspecial system call named  ptrace that gives one process the ability to read and write the state of adifferent process. Thus, GDB's target side is mostly about making  ptrace calls and interpreting theresults", "comment": "\u8fd9\u91cc\u63d0\u5230\u4e86ptrace\uff0c\u5b83\u8ba9\u4e00\u4e2a\u8fdb\u7a0b\u53ef\u4ee5\u8bfb\u53d6\u548c\u4fee\u6539\u53e6\u5916\u4e00\u4e2a\u8fdb\u7a0b\u7684\u72b6\u6001\uff0c\u5b83\u662fgdb\u7684\u57fa\u77f3", "time": "2015-09-08 22:35:06"}, {"content": "The single-stepping command  step conceals a complicated dance going on behind the scenes. When theuser asks to step to the next line in the program, the target side is asked to execute only a single instructionof the program and then stop it again (this is one of the things that  ptrace can do). Upon being informedthat the program has stopped, GDB asks for the program counter (PC) register (another target sideoperation) and then compares it with the range of addresses that the symbol side says is associated with thecurrent line. If the PC is outside that range, then GDB leaves the program stopped, figures out the newsource line, and reports that to the user", "comment": "\u5355\u6b65\u8c03\u8bd5\u7684\u539f\u7406\uff0c\u501f\u52a9\u4e86ptrace\u548cpc\uff08\u7a0b\u5e8f\u8ba1\u6570\u5668\uff09", "time": "2015-09-08 22:46:49"}, {"content": "\"Host\" definitions are for the machine that GDB itself runs on, and might include things like the sizes ofthe host's integer types", "time": "2015-09-08 22:51:36"}, {"content": "\"Target\" definitions are specific to the machine running the program being debugged. If the target is thesame as the host, then we are doing \"native\" debugging, otherwise it is \"cross\" debugging, using somekind of wire connecting the two systems", "time": "2015-09-08 22:52:29"}, {"content": "Several kinds of breakpoint-like objects actually share the breakpoint  struct, including watchpoints,catchpoints, and tracepoints. This helps ensure that creation, manipulation, and deletion facilities areconsistently available", "time": "2015-09-08 22:55:37"}, {"content": "Symbol tables are a key data structure to GDB, and can be quite large, sometimes growing to occupymultiple gigabytes of RAM. To some extent, this is unavoidable; a large application in C++ can have millionsof symbols in its own right, and it pulls in system header files which can have millions more symbols. Eachlocal variable, each named type, each value of an enum\u2014all of these are separate symbols", "time": "2015-09-08 22:57:04"}, {"content": "In addition to symbol tables that basically map character strings to address and type information, GDB", "time": "2015-09-08 22:58:08"}, {"content": "builds line tables that support lookup in two directions; from source lines to addresses, and then fromaddresses back to source lines. (For instance, the single-stepping algorithm described earlier cruciallydepends on the address-to-source mapping.)", "comment": "\u4ee3\u7801\u4e0e\u5730\u5740\u7684\u6620\u5c04\u8868", "time": "2015-09-08 22:58:14"}, {"content": "The procedural languages for which GDB was designed share a common runtime architecture, in thatfunction calls cause the program counter to be pushed on a stack, along with some combination of functionarguments and local arguments. The assemblage is called a stack frame, or \"frame\" for short, and at anymoment in a program's execution, the stack consists of a sequence of frames chained together", "time": "2015-09-08 23:02:32"}, {"content": "The reading process starts with the BFD library. BFD is a sort of universal library for handling binary andobject files; running on any host, it can read and write the original Unix  a.out format, COFF (used onSystem V Unix and MS Windows), ELF (modern Unix, GNU/Linux, and most embedded systems), and someother file formats", "time": "2015-09-08 23:05:55"}, {"content": "Most of the symbolic information will never be looked at in a session, since it is local to functions that theuser may never examine. So, when GDB first pulls in a program's symbols, it does a cursory scan throughthe symbolic information, looking for just the globally visible symbols and recording only them in the symboltable. Complete symbolic info for a function or method is filled in only if the user stops inside it", "time": "2015-09-08 23:10:08"}, {"content": "The target side is all about manipulation of program execution and raw data. In a sense, the target side is acomplete low-level debugger; if you are content to step by instructions and dump raw memory, you can useGDB without needing any symbols at all. (You may end up operating in this mode anyway, if the programhappens to stop in a library whose symbols have been stripped out.", "comment": "gdb\u540e\uff0c\u53d1\u73b0\u90e8\u5206\u6808\u5e27\u4fe1\u606f\u4e3a\u7a7a\uff0c\u662f\u5426\u53ea\u6709\u7b26\u53f7\u88abstripped\u540a\u8fd9\u4e00\u4e2a\u539f\u56e0\uff1f\u8fd8\u662f\u4e5f\u6709\u53ef\u80fd\u6808\u88ab\u5199\u574f\uff1f", "time": "2015-09-08 23:12:01"}, {"content": "Originally the target side of GDB was composed of a handful of platform-specific files that handled thedetails of calling  ptrace, launching executables, and so on. This is not sufficiently flexible for long-runningdebugging sessions, in which the user might switch from local to remote debugging, switch from files to coredumps to live programs, attach and detach, etc.", "time": "2015-09-08 23:17:20"}, {"content": "Each target vector is implemented as a structureof several dozen function pointers (often called \"methods\"), whose purposes range from the reading andwriting of memory and registers, to resuming program execution, to setting parameters for the handling ofshared libraries. There are about 40 target vectors in GDB,", "time": "2015-09-08 23:18:33"}, {"content": "As a program that works directly with the instructions of a CPU, GDB needs in-depth knowledge about thedetails of the chip. It needs to know about all the registers, the sizes of the different kinds of data, the sizeand shape of the address space, how the calling convention works, what instruction will cause a trapexception, and so on. GDB's code for all this typically ranges from 1,000 to over 10,000 lines of C,depending on the architecture's complexity", "comment": "\u786c\u4ef6\u67b6\u6784\u5bf9\u4e8egdb\u7684\u5f71\u54cd", "time": "2015-09-09 00:37:48"}, {"content": "In addition to the single-stepping loop mentioned above, theprogram may be hitting trap instructions and reporting the exception to GDB. If the exception is due to thetrap being a breakpoint inserted by GDB, it then tests the breakpoint's condition, and if false, it removes thetrap, single-steps the original instruction, re-inserts the trap, and then lets the program resume", "comment": "\u65ad\u70b9\u89e6\u53d1\u9677\u9631\u6307\u4ee4", "time": "2015-09-09 00:41:35"}, {"content": "GDB is fundamentally a command-line debugger. Over time people have tried various schemes to make itinto a graphical windowed debugger but, despite all the time and effort, none of these are universallyaccepted", "time": "2015-09-09 00:44:25"}, {"content": "After seeing some of the changes we made, you might be thinking: Why didn't we do things right in the firstplace? Well, we just weren't smart enough", "comment": "\u786e\u5b9e\uff0c\u6211\u4eec\u8fd8\u4e0d\u591f\u806a\u660e\uff0c\u7ecf\u9a8c\u4e5f\u4e0d\u591f\u4e30\u5bcc", "time": "2015-09-09 00:51:11"}], "duokanbookid": "g5505788d04b6b56bc28fec733308f96", "title": "The Architecture of Open Source Applications: GDB"}